\documentclass[a4paper, 11pt]{report}
\usepackage{blindtext}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{titlesec}
\usepackage{fancyhdr}
\usepackage{geometry}

\usepackage[english]{babel}
\usepackage{apacite}

\geometry{ margin=30mm }
\counterwithin{subsection}{section}
\renewcommand\thesection{\arabic{section}.}
\renewcommand\thesubsection{\thesection\arabic{subsection}.}
\usepackage{tocloft}
\renewcommand{\cftchapleader}{\cftdotfill{\cftdotsep}}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
\setlength{\cftsecindent}{2.2em}
\setlength{\cftsubsecindent}{4.2em}
\setlength{\cftsecnumwidth}{2em}
\setlength{\cftsubsecnumwidth}{2.5em}


\begin{document}
\titleformat{\section}
{\normalfont\fontsize{15}{0}\bfseries}{\thesection}{1em}{}
\titlespacing{\section}{0cm}{0.5cm}{0.15cm}
\titleformat{\subsection}
{\normalfont\fontsize{13}{0}\bfseries}{\thesubsection}{0.5em}{}
\titlespacing{\section}{0cm}{0.5cm}{0.15cm}

%=======================================================================================

\begin{titlepage}
\center 
\textbf{\huge INFO1111: Computing 1A Professionalism}\\[0.75cm]
\textbf{\huge 2022 Semester 1}\\[2cm]
\textbf{\huge Practice: Team Project Report}\\[3cm]

\textbf{\huge Submission number: ??}\\[0.75cm]
\textbf{\huge Team Members:}\\[0.75cm]
\textbf{\large
    \begin{tabular}{|p{0.5\textwidth}|p{0.3\textwidth}|p{0.2\textwidth}|}
        \hline
        Name & Student ID & Levels being attempted in this submission\\
        \hline
        ?? & ?? & e.g. 1,2 \\
        ?? & ?? & ?? \\
        ?? & ?? & ?? \\
        ?? & ?? & ?? \\
        \hline
    \end{tabular}
}\\[0.75cm]
\end{titlepage}

%=======================================================================================

\tableofcontents

%=======================================================================================

\newpage
\section*{General Instructions}

You should use this \LaTeX\ template to generate your team project report. Keep in mind the following key points:
\begin{itemize}
    \item When we assess your report, you are not given a mark. Instead we will indicate (separately, for each team member) whether each level is ''achieved''.
    \item In order to pass the unit, you must achieve at least level 1. 
    \item In order to achieve level 2, you must first have achieved level 1, and so on for each level up to level 4. This means that we will not assess a higher level until a lower level has been achieved (though we will review one level higher and give you feedback to help you in refining your work).
    \item Some parts of the report are completed as a team and other parts require each student to complete a different section. This means that for each submission, some members of the team may have completed their work for a given section, but other members may not. It also is therefore possible that some members of the team may achieve a specified level and other members of the team may not yet have achieved that level.
    \item Even if some members are completing their material for a given level, and others are not, your team members will still need to work together to edit and compile the report.  The only exception to this is where a member of the team has already achieved the level they are targeting in a previous submission and has decided to not attempt higher levels, and so is not contributing any further (this should be obvious because no level is indicated for that student on the cover page).
    \item When completing each section you should remove the explanation text and replace it with your material.
\end{itemize}

For each submission you will add new details to this report, and/or update previous sections (where previous work was not good enough to have achieved the relevant level). In particular:

\begin{itemize}
    \item \textbf{General:} For each submission, each student can attempt up to 2 levels. You must also successfully achieve each lower level before you can be assessed at a higher level. For example, in the first submission you might attempt only level 1, but not be successful in achieving that level. You then reattempt level 1 and add in level 2 in the second submission and are successful in achieving level 1 but not level 2. For the third and final submission you could then attempt level 2, or levels 2 and 3 - or even just choose to not submit anything further and remain at level 1).
    \item \textbf{Submission 1:} You should complete at least the material for level 1 (since achieving level 1 is required to pass the unit). Each member of the team can also optionally choose to complete the material for level 2.\\
    \textit{Note 1: If you do not complete the level 2 information then you obviously cannot achieve level 2 at this stage. This does not stop you from attempting level 2 in Deliverable 2 or 3, but it will make it more difficult to achieve the higher levels later in the semester.}
    \textit{Note 2: To be able to achieve Level 1 in submission one your team has to achieve level 1 in the group component (Section 1.1) and you have to achieve Level 1 in the individual component (i.e. your assigned section 1.2, 1.3, 1.4 or 1.5)}
    \item \textbf{Submission 2:} Each member of your team will complete additional sections, but because you are submitting a single document, you need to work together to compile your results together and generate the final submission.\\
    If you did not achieve level 1 in your first submission, then you should revise the material for level 1 based on the feedback, and optionally you can also complete level 2.\\
    If you achieved level 1 in your first submission, then each team member can optionally complete the material for levels 2 and 3.
    \textit{Note: If you do not achieve level 1 with this submission then the highest level you will be able to achieve in the final submission will be level 2. If you achieve level 1, but not level 2, with this submission then the highest level you will be able to achieve with the final submission is level 3.}
    \item \textbf{Submission 3:} Again, you can correct sections where you did not achieve the specified level in the previous submission, and you complete additional sections.\\
    If you still have not achieved level 1, then you should revise the material for level 1 based on the feedback, and again optionally you can also complete level 2.\\
    For those at level 1, you can choose to complete the material for levels 2 and 3.\\
    For those at level 2, you can choose to complete the material for levels 3 and 4.\\
    For those at level 3, you can choose to complete the material for level 4.
\end{itemize}

Whilst the team project is just that -- a team project -- it has been designed to also allow different members of the team to achieve different outcomes. We do expect you to work together as a team. If you do come across problems working together then the first step should be to discuss this with your tutor. Note: If you are having problems you should approach your tutor as soon as you can to make them aware of the difficulties you are having with your team.

Finally, you should also ensure that any resources you use are suitably referenced, and references are included into the reference list at the end of this document. You should use APA 6th reference style \cite{apa6}.

%=======================================================================================

\newpage
\section{Level 1: Basic Skills}

Level 1 focuses on basic technical skills (related to \LaTeX\ and Git) and the types of skills used in different computing jobs.

\subsection{Developing industry skills}

This section is completed as a team.\\
Throughout your Computing degree we will help you learn a range of new skills. Once you graduate however you will need to continue to learn new languages, new tools, new applications, etc. For this section you need to identify 5 approaches you can take to this continual learning. You should then put these in order from most effective to least effective, and then explain the circumstances in which each approach might be appropriate. (Target = $\sim$100 words per skill = $\sim$500 words total).

\subsection{Skills: Jason Kam : Computer Science}

1. Problem Solving
Probably the most important skill for a computer scientist to have is the ability to problem solve as pretty it is essentially their main job. Whether it's debugging an existing program, using programming to solve a real issue or making a preexisting solution more efficient, having the ability to problem solve is a must have skillset for them. Good computer scientists will employ a variety of different skills that help them solve solutions such as practicing common problems, dividing big problems into sub problems and/or writing solutions in pseudocode first.

2. Code Style
The ability to write aesthetic code or in python, "pythonic" code is extremely important as most of the time, a programmers code will be viewed by other employees, which makes layout/readability an indispensable skill. Not only does it make it easier for someone including the programmer to debug the code should it not work properly, but it also reduces the chance of bugs occurring due to poor code writing style. Adding comments to their code as well as implementing classes/functions where necessary ensures that computer scientists write programs that are easier to follow/understand.

3. Ethics
Since utilizing search engines is an extremely important part of being a computer scientist, the ability to correctly reference code that has been reused is important not just in school but when employed. After all, if someone has written an much more efficient 
algorithm, then obviously a programmer should use it to improve their program. Other ethics that a computer scientist must be familiar with include data protection/privacy, which means taking into account the protection of private data when writing programs (e.g hashing passwords before storing it in a database).

4. Ability to use Git/Github
A computer scientist rarely works alone, and in order to effectively work on a project as a team, an external tool such as Git is vital to ensure that a project develops as intended. By utilizing Git, it allows a group of computer scientists to work together without creating any conflicts or bugs that may arise through the use of pulls, pushes, commits and branches. For example, if after a commit, a project no longer works, it is extremely easy to identify where the bug is occurring by looking at which branch of the project caused it to no longer work. Using Git also allows you to see which changes to a project are better by committing the updates to different branches. 

5. Able to program in different languages
Having a wide range of languages in a computer scientists skillset allows them to program much more complicated and efficient programs. For example, designing a web application typically requires at minimum, the ability to code in Python, Javascript, HTML and CSS with most web applications also needing languages such as SQL in order to store data. Being able to program in both high and lower level languages also allows for much more flexibility, as both types of languages offer their own benefits to using it. For example, coding in C provides faster runtimes at the cost of user managed memory while Python does not require manual memory management but is slower than C due to being a higher level language.

6. Communication
Communication is an important skill that anybody working any job requires and a computer scientist is no different. The ability to communicate effectively to fellow employees and their bosses allows them to understand what goals need to be achieved, including the exact specifications that their program needs to meet. Without good communication, a computer scientist may not completely understand the problem at hand which renders their skillsets useless. Having the capacity to communicate properly with other employees can also allow a computer scientist to learn new skills, since typically in a project team, each person is assigned a different task depending on their respective skillset.


7. Searching skills
With all the different languages, algorithms and data structures that exist in programming, computer scientist typically cannot remember all of them. Therefore, the ability to efficiently use search engines such as google in order to find solutions or remember syntax from a language that they might not have coded in for a long time is extremely important. After all, there is no need to waste memory space on trivial things that can be googled anyway and computer science/programming encompasses this idea entirely. This allows programmers to focus on remembering more important things such as the most useful and common algorithms and data structures used in common problems, or refine their ability to code in a main language such as Python without having to worry about remembering all niche solutions or the syntax in every language.

8. Knowledge of Algorithms and Data Structures
As a computer scientist, just being able to solve a solution is typically not enough. By having an extensive knowledge on different algorithms and data structures, they should be able to design a program that solves a solution using the most optimal time and space. For example, typically solutions that are done through brute force may have badly optimised times such as O(n^2) time or a solution that is fast but has poor space management. Using algorithms such as binary search, divide and conquer, sliding windows can often drastically cut time and space that a program takes. Data structures such as hash tables, binary search trees, lists can also help optimize time, but good computer scientists will understand the importance between balancing space and time optimization, as speeding up programs may often increase the amount of space that needs to be allocated and vice versa.


\subsection{Skills: add student 2 name here : Data Science}

Your text goes here

\subsection{Skills: add student 3 name here : Software Development}
fs
Your text goes here

\subsection{Skills: add student 4 name here : Cyber Security}

Your text goes here


%=======================================================================================

\newpage
\section{Level 2: Basic Technology}

Level 2 focuses on initial evaluation of the tech stack that is used by a selected company. All companies make use of a range of technologies, and these technologies need to work together. A tech stack is basically just this collection of technologies that collectively enable a company's systems. As an example, one of the most common technology stacks for supporting web servers is LAMP: Linux as the underlying operating system; Apache as a web server; MySQL as the supporting database; and Perl (or more recently PHP or Python) as the programming language.

Each student should choose a different tech stack and explain the role of each of the different technologies in that stack. Note that prior to researching your proposed tech stack and spending time writing about it, it might be a good idea to check with your tutor as to whether your chosen stack is suitable. (Target = $\sim$200-400 words per student).

\subsection{Tech Stack: add student 1 name here}

Your text goes here

\subsection{Tech Stack: add student 2 name here}

Your text goes here

\subsection{Tech Stack: add student 3 name here}

Your text goes here

\subsection{Tech Stack: add student 4 name here}

Your text goes here


%=======================================================================================

\newpage
\section{Level 3: Advanced Skills}

Level 3 focuses on more advanced technical skills (\LaTeX\ and Git) and analysis of linkages and relationships between the items in the company tech stack.

The following is a list of advanced Git and \LaTeX\ skills/features. Each student should select one pair of items from each list and demonstrate actual use of each item (either through activity in Git, or through including items in this report). (Target = $\sim$100 words per student for each feature).
\begin{itemize}
    \item Git
    \begin{itemize}
        \item Rebasing and Ignoring files
        \item Forking and Special files
        \item Resetting and Tags
        \item Reverting and Automated merges
        \item Hooks and Tags
    \end{itemize}
    \item \LaTeX\ 
    \begin{itemize}
        \item Cross-referencing and Custom commands
        \item Footnotes/margin notes and creating new environments
        \item Floating figures and editing style sheets
        \item Graphics and advanced mathematical equations
        \item Macros and hyperlinks
    \end{itemize}
\end{itemize}

\subsection{Advanced features: add student 1 name here}

Explain your use of the advanced Git and \LaTeX\ features. 

\subsection{Advanced features: add student 2 name here}

Explain your use of the advanced Git and \LaTeX\ features. 

\subsection{Advanced features: add student 3 name here}

Explain your use of the advanced Git and \LaTeX\ features. 

\subsection{Advanced features: add student 4 name here}

Explain your use of the advanced Git and \LaTeX\ features. 



%=======================================================================================

\newpage
\section{Level 4: Advanced Knowledge}

Level 4 focuses on analysing your particular tech stack and considering alternatives. Each student should consider the tech stack they described for Level 2, and then discuss each of the following points:
\begin{itemize}
    \item What are the strengths and limitations of this stack? (Target = $\sim$200 words).
    \item What alternatives exist, and under what situations might these alternatives be a better choice? (Target = $\sim$200 words).
\end{itemize}

\subsection{Advanced Knowledge: add student 1 name here}

Your text goes here

\subsection{Advanced Knowledge: add student 2 name here}

Your text goes here

\subsection{Advanced Knowledge: add student 3 name here}

Your text goes here

\subsection{Advanced Knowledge: add student 4 name here}

Your text goes here



%=======================================================================================

\newpage

\bibliographystyle{apacite}
\bibliography{main}

\end{document}
\end{report}
